---
title : TCP/IP学习笔记（二）TCP三次握手
date : 2018-02-23
categories : TCP/IP
tags : TCP/IP
---

TCP是一种面向连接的流传输协议，提供了对数据传输时的各种控制功能，比如

* 当丢包时可以重新发送
* 即使数据到达顺序错乱也可以保证数据的有序性

由于TCP是面向连接的协议，所以必须在确定通信对端存在时才会发送数据，即三次握手。

<!--more-->

好比于A和B打电话，电话拨通后

> A对B说:"你好，我是A，你能听见我说话吗"(第一次握手)
>
> B听到A的询问回答说:"你好，我能听见你说话，你能听见我说话吗"(第二次握手)
>
> A听见B的回复后告诉B说:"我也能听见你说话"(第三次握手)
>
> 此时A和B都已确定对方能够听见自己的声音，即A和B的通讯连接已经建立

------



# 三次握手

三次握手主要需要解决以下三个问题

- 要使每一方能够知道对方的存在
- 要允许双方协商一些参数（如最大窗口值，是否使用窗口扩大选项和时间戳选项以及服务质量等）
- 能够对运输实体资源（如缓存大小，连接表中的项目等）进行分配

三次握手的时序图如下，其中，客户端进行主动连接，称为主动打开(执行connect)，而服务器进行连接请求的接收，称为被动打开(执行accept)

![](https://s1.ax1x.com/2018/02/23/9aVzh6.png)



## 三次握手流程

### 第一次握手

* 客户端调用connect函数，请求连接服务器，并发送连接请求报文段，此时报文首部的同步位SYN = 1，同时选择一个初始序列号seq = x放在报文段中。此时客户端状态变为SYN_SENT，表示同步已发送。

当电话接通后A询问B:"你能听见我说话吗？"

> TCP规定，SYN = 1的报文段不能携带数据，但是需要消耗一个序列号

### 第二次握手

* 服务器调用accept函数，当收到客户端的连接请求后，将收到的报文段记录在本地（获取序列号信息），随后发送自己的报文段，该报文段中的SYN位和ACK位都被置为1，表示既是一个同步报文也是一个应答报文。此外，报文中需要包含自己的初始序列号sqe = y以及希望下次收到的数据的序列号，由于刚才收到的序列号为x，所以下次希望接受的序列号为x + 1。至此服务器状态变为SYN_RCVD，表示同步已收到。

B回复A说:"我能听见你说话，你能听见我说话吗？"

> TCP规定，该报文段也不能携带数据，但是也需要消耗一个序列号

### 第三次握手

* 客户端收到服务器的报文段后发送确认报文段，该报文段首部ACK确认位被置1，序列号为x + 1，希望下次接收的数据序列号为y + 1。随后状态变为ESTABLISHED，connect函数返回。
* 服务器收到客户端发来的确认报文段，确认连接建立，状态变为ESTABLISHED，accept函数返回

A听到B的回复后确认B能听见自己的声音，同时告诉B自己也能听见他的声音。B听见A的回复后确认A能听见自己的声音，此时双方可以正常进行通话

![](https://s1.ax1x.com/2018/02/23/9aAKc4.jpg)

------



# 文件描述符耗尽时的accept处理

accept会先后执行两步，任何位置出错都会直接返回

* 选择一个空闲的文件描述符充当套接字描述符
* 从TCP缓冲区的连接队列中取出一个连接请求，创建连接

然而考虑一种极端情况，当服务器本地文件描述符耗尽时，accept在第一步就会出错返回，根本没有从缓冲区中取出连接请求。此时如果重新判断，那么监听套接字仍然是可读的，又开始accept，结果又发现耗尽，就会造成死循环。

解决的办法就是想办法让accept正常返回，成功接收请求。可以在服务器初始化时占用一个空闲描述符(通常是打开一个文件)，当出现上述文件描述符耗尽的情况时，释放占用的描述符，此时就会出现一个空闲描述符，重新调用accept函数后会正常返回，然后再显示关闭连接，重新打开文件占用空闲描述符

------



# 以打电话为例解释二/三/四次握手

## 二次握手

A：你好，我是A，你能听见我说话吗

B：你好，我能听见你说话，你能听见我说话吗

A：今天跟你谈谈事情1，balabalalba....

B：你好，我能听见你说话，你能听见我说话吗

A：今天跟你谈谈事情2，又balabalabala...

B：我tm问你能不能听见我说话，fuck!

A：今天跟你谈谈事情3，再balabalabala...

B：...

> 显然B无法确定A是否能听见自己说话，所以会一直询问。而A已经知道B能听见自己说话，所以会直接谈具体事情，导致无法进行正常交流

## 三次握手

A：你好，我是A，你能听见我说话吗

B：你好，我能听见你说话，你能听见我说话吗

A：我能听见你说话

B：OK

A：今天跟你谈谈事情1，balabalabala...

B：噢这个事啊，balabalabala...

>A和B都已确定对方能够听见自己说话，所以可以进行正常交流

## 四次握手

A：你好，我是A，你能听见我说话吗

B：你好，我能听见你说话

B：你好，我是B，你能听见我说话吗

A：你好，我能听见你说话

B：OK

A：今天跟你谈谈事情1，balabalabala...

B：噢这个事啊，balabalabala...

>A和B也可以进行正常交流，但是第二三次握手时B完全可以浓缩成"我能听见你说话，你能听见我说话吗"

# 三次握手抓包分析

下面利用tcpdump命令在linux环境下进行三次握手的抓包分析，通过抓包，可以看到连接过程中一些主要数据的传输

在上面的介绍中得知三次握手的过程中会进行如下数据交互（仅考虑序列号，其中A是客户端，B是服务器）

A->B：SYN同步报文段，带有起始序列号seq = x

B->A：SYN/ACK同步/确认报文段，带有起始序列号seq = y以及希望下次接收的序列号ack = x + 1

A->B：ACK确认报文段，对服务器的确认ack = y + 1

首先需要有服务器和客户端程序，自己敲两个就行，然后启动tcpdump命令

* -S表示显示的序列号是绝对值，而不是相对值
* -i lo指定网络接口，可以通过ifconfig命令查看接口
* tcp表示只抓取tcp数据包
* port 9999指定抓取端口，这里假设服务器监听9999端口

```shell
sudo tcpdump -S -i lo tcp port 9999
```

随后运行服务器和客户端，观察tcpdump命令输出

![](https://s1.ax1x.com/2018/02/25/9wAV4P.png)

输出结果分为三行，分别对应每一次握手，可以看到

* 客户端发送给服务器的SYN同步报文段中包含自己的起始序列号2360165387
* 服务器发送给客户端的SYN/ACK报文段中包含自己的起始序列号2184124889以及希望下次从客户端接收的序列号2360165388（可以看到正是第一次握手发送的序列号加一，因为SYN报文段占用了一个序列号）
* 客户端发送给服务器ACK报文段中包含希望下次从服务器接收的序列号2184124890，可以看到同样是服务器上次传送的序列号加一